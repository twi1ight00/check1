using System;
using System.Collections.Generic;
using System.Configuration;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Xml;
using Microsoft.Practices.ObjectBuilder2;
using Microsoft.Practices.Unity.Configuration.ConfigurationHelpers;
using Microsoft.Practices.Unity.Configuration.Properties;
using Microsoft.Practices.Unity.Utility;

namespace Microsoft.Practices.Unity.Configuration;

/// <summary>
/// Configuration element representing a constructor configuration.
/// </summary>
public class ConstructorElement : InjectionMemberElement
{
	private const string ParametersPropertyName = "";

	/// <summary>
	/// The parameters of the constructor to call.
	/// </summary>
	[ConfigurationProperty("", IsDefaultCollection = true)]
	public ParameterElementCollection Parameters => (ParameterElementCollection)base[""];

	/// <summary>
	/// Each element must have a unique key, which is generated by the subclasses.
	/// </summary>
	public override string Key => "constructor";

	/// <summary>
	/// Element name to use to serialize this into XML.
	/// </summary>
	public override string ElementName => "constructor";

	/// <summary>
	/// Write the contents of this element to the given <see cref="T:System.Xml.XmlWriter" />.
	/// </summary>
	/// <remarks>The caller of this method has already written the start element tag before
	/// calling this method, so deriving classes only need to write the element content, not
	/// the start or end tags.</remarks>
	/// <param name="writer">Writer to send XML content to.</param>
	public override void SerializeContent(XmlWriter writer)
	{
		foreach (ParameterElement parameter in Parameters)
		{
			writer.WriteElement("param", parameter.SerializeContent);
		}
	}

	/// <summary>
	/// Return the set of <see cref="T:Microsoft.Practices.Unity.InjectionMember" />s that are needed
	/// to configure the container according to this configuration element.
	/// </summary>
	/// <param name="container">Container that is being configured.</param>
	/// <param name="fromType">Type that is being registered.</param>
	/// <param name="toType">Type that <paramref name="fromType" /> is being mapped to.</param>
	/// <param name="name">Name this registration is under.</param>
	/// <returns>One or more <see cref="T:Microsoft.Practices.Unity.InjectionMember" /> objects that should be
	/// applied to the container registration.</returns>
	public override IEnumerable<InjectionMember> GetInjectionMembers(IUnityContainer container, Type fromType, Type toType, string name)
	{
		ConstructorInfo constructorInfo = FindConstructorInfo(toType);
		GuardIsMatchingConstructor(toType, constructorInfo);
		return new InjectionMember[1] { MakeInjectionMember(container, constructorInfo) };
	}

	private ConstructorInfo FindConstructorInfo(Type typeToConstruct)
	{
		return typeToConstruct.GetConstructors().Where(ConstructorMatches).FirstOrDefault();
	}

	private bool ConstructorMatches(ConstructorInfo candiateConstructor)
	{
		ParameterInfo[] parameters = candiateConstructor.GetParameters();
		if (parameters.Length != Parameters.Count)
		{
			return false;
		}
		return Sequence.Zip(Parameters, parameters).All((Pair<ParameterElement, ParameterInfo> pair) => pair.First.Matches(pair.Second));
	}

	private InjectionMember MakeInjectionMember(IUnityContainer container, ConstructorInfo constructorToCall)
	{
		List<InjectionParameterValue> list = new List<InjectionParameterValue>();
		ParameterInfo[] parameters = constructorToCall.GetParameters();
		for (int i = 0; i < parameters.Length; i++)
		{
			list.Add(Parameters[i].GetParameterValue(container, parameters[i].ParameterType));
		}
		return new InjectionConstructor(list.ToArray());
	}

	private void GuardIsMatchingConstructor(Type typeToConstruct, ConstructorInfo ctor)
	{
		if (ctor == null)
		{
			string text = string.Join(", ", Parameters.Select((ParameterElement p) => p.Name).ToArray());
			throw new InvalidOperationException(string.Format(CultureInfo.CurrentCulture, Resources.NoMatchingConstructor, typeToConstruct.FullName, text));
		}
	}
}
