using System;
using System.Collections.Generic;
using System.Configuration;
using System.Xml;
using Microsoft.Practices.Unity.Configuration;
using Microsoft.Practices.Unity.Configuration.ConfigurationHelpers;
using Microsoft.Practices.Unity.Utility;

namespace Microsoft.Practices.Unity.InterceptionExtension.Configuration;

/// <summary>
/// Configuration element that lets you specify additional interfaces
/// to add when this type is intercepted.
/// </summary>
public class AddInterfaceElement : InjectionMemberElement
{
	private const string TypeNamePropertyName = "type";

	/// <summary>
	/// Type of interface to add.
	/// </summary>
	[ConfigurationProperty("type", IsRequired = true)]
	public string TypeName
	{
		get
		{
			return (string)base["type"];
		}
		set
		{
			base["type"] = value;
		}
	}

	/// <summary>
	/// Each element must have a unique key, which is generated by the subclasses.
	/// </summary>
	public override string Key => "addInterface: " + TypeName;

	/// <summary>
	/// Write the contents of this element to the given <see cref="T:System.Xml.XmlWriter" />.
	/// </summary>
	/// <remarks>The caller of this method has already written the start element tag before
	/// calling this method, so deriving classes only need to write the element content, not
	/// the start or end tags.</remarks>
	/// <param name="writer">Writer to send XML content to.</param>
	public override void SerializeContent(XmlWriter writer)
	{
		Guard.ArgumentNotNull(writer, "writer");
		writer.WriteAttributeString("type", TypeName);
	}

	/// <summary>
	/// Return the set of <see cref="T:Microsoft.Practices.Unity.InjectionMember" />s that are needed
	/// to configure the container according to this configuration element.
	/// </summary>
	/// <param name="container">Container that is being configured.</param>
	/// <param name="fromType">Type that is being registered.</param>
	/// <param name="toType">Type that <paramref name="fromType" /> is being mapped to.</param>
	/// <param name="name">Name this registration is under.</param>
	/// <returns>One or more <see cref="T:Microsoft.Practices.Unity.InjectionMember" /> objects that should be
	/// applied to the container registration.</returns>
	public override IEnumerable<InjectionMember> GetInjectionMembers(IUnityContainer container, Type fromType, Type toType, string name)
	{
		Type additionalInterface = TypeResolver.ResolveType(TypeName);
		return new AdditionalInterface[1]
		{
			new AdditionalInterface(additionalInterface)
		};
	}
}
