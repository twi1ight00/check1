using System;
using System.Collections.Generic;
using System.Configuration;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Xml;
using Microsoft.Practices.ObjectBuilder2;
using Microsoft.Practices.Unity.Configuration.ConfigurationHelpers;
using Microsoft.Practices.Unity.Configuration.Properties;
using Microsoft.Practices.Unity.Utility;

namespace Microsoft.Practices.Unity.Configuration;

/// <summary>
/// A configuration element representing a method to call.
/// </summary>
public class MethodElement : InjectionMemberElement
{
	private const string NamePropertyName = "name";

	private const string ParametersPropertyName = "";

	private static int methodElementCounter;

	private readonly int methodCount;

	/// <summary>
	/// Name of the method to call.
	/// </summary>
	[ConfigurationProperty("name", IsRequired = true)]
	public string Name
	{
		get
		{
			return (string)base["name"];
		}
		set
		{
			base["name"] = value;
		}
	}

	/// <summary>
	/// Parameters to the method call.
	/// </summary>
	[ConfigurationProperty("", IsDefaultCollection = true)]
	public ParameterElementCollection Parameters => (ParameterElementCollection)base[""];

	/// <summary>
	/// Each element must have a unique key, which is generated by the subclasses.
	/// </summary>
	public override string Key => string.Format(CultureInfo.InvariantCulture, "method:{0}:{1}", Name, methodCount);

	/// <summary>
	/// Element name to use to serialize this into XML.
	/// </summary>
	public override string ElementName => "method";

	/// <summary>
	/// Construct a new instance of <see cref="T:Microsoft.Practices.Unity.Configuration.MethodElement" />.
	/// </summary>
	public MethodElement()
	{
		methodCount = Interlocked.Increment(ref methodElementCounter);
	}

	/// <summary>
	/// Write the contents of this element to the given <see cref="T:System.Xml.XmlWriter" />.
	/// </summary>
	/// <remarks>The caller of this method has already written the start element tag before
	/// calling this method, so deriving classes only need to write the element content, not
	/// the start or end tags.</remarks>
	/// <param name="writer">Writer to send XML content to.</param>
	public override void SerializeContent(XmlWriter writer)
	{
		writer.WriteAttributeString("name", Name);
		foreach (ParameterElement parameter in Parameters)
		{
			writer.WriteElement("param", parameter.SerializeContent);
		}
	}

	/// <summary>
	/// Return the set of <see cref="T:Microsoft.Practices.Unity.InjectionMember" />s that are needed
	/// to configure the container according to this configuration element.
	/// </summary>
	/// <param name="container">Container that is being configured.</param>
	/// <param name="fromType">Type that is being registered.</param>
	/// <param name="toType">Type that <paramref name="fromType" /> is being mapped to.</param>
	/// <param name="name">Name this registration is under.</param>
	/// <returns>One or more <see cref="T:Microsoft.Practices.Unity.InjectionMember" /> objects that should be
	/// applied to the container registration.</returns>
	public override IEnumerable<InjectionMember> GetInjectionMembers(IUnityContainer container, Type fromType, Type toType, string name)
	{
		MethodInfo methodToCall = FindMethodInfo(toType);
		GuardIsMatchingMethod(toType, methodToCall);
		return new InjectionMember[1] { MakeInjectionMember(container, methodToCall) };
	}

	private MethodInfo FindMethodInfo(Type typeToInitialize)
	{
		return typeToInitialize.GetMethods().Where(MethodMatches).FirstOrDefault();
	}

	private InjectionMember MakeInjectionMember(IUnityContainer container, MethodInfo methodToCall)
	{
		List<InjectionParameterValue> list = new List<InjectionParameterValue>();
		ParameterInfo[] parameters = methodToCall.GetParameters();
		for (int i = 0; i < parameters.Length; i++)
		{
			list.Add(Parameters[i].GetParameterValue(container, parameters[i].ParameterType));
		}
		return new InjectionMethod(Name, list.ToArray());
	}

	private bool MethodMatches(MethodInfo method)
	{
		if (method.Name != Name)
		{
			return false;
		}
		ParameterInfo[] parameters = method.GetParameters();
		if (parameters.Length != Parameters.Count)
		{
			return false;
		}
		return Sequence.Zip(Parameters, parameters).All((Pair<ParameterElement, ParameterInfo> pair) => pair.First.Matches(pair.Second));
	}

	private void GuardIsMatchingMethod(Type typeToInitialize, MethodInfo methodToCall)
	{
		if (methodToCall == null)
		{
			string text = string.Join(", ", Parameters.Select((ParameterElement p) => p.Name).ToArray());
			throw new InvalidOperationException(string.Format(CultureInfo.CurrentCulture, Resources.NoMatchingMethod, typeToInitialize, Name, text));
		}
	}
}
