using System.Collections.Generic;
using System.Text;
using ns33;

namespace ns24;

internal sealed class Class541
{
	internal enum Enum137 : long
	{
		const_0 = 1L,
		const_1,
		const_2,
		const_3,
		const_4,
		const_5,
		const_6,
		const_7,
		const_8,
		const_9,
		const_10
	}

	public const long long_0 = -27273042329600L;

	public const long long_1 = 27273042316900L;

	public static readonly Class1151 class1151_0 = new Class1151("*/", "+-", "+/", "?:", "abs", "at2", "cat2", "cos", "max", "min", "mod", "pin", "sat2", "sin", "sqrt", "tan", "val");

	public static readonly int[] int_0 = new int[17]
	{
		3, 3, 3, 3, 1, 2, 3, 2, 2, 2,
		3, 3, 3, 2, 1, 2, 1
	};

	private Enum113 enum113_0;

	private long long_2;

	private long long_3;

	private long long_4;

	internal string string_0;

	private bool bool_0;

	public string Name
	{
		get
		{
			return string_0;
		}
		set
		{
			string_0 = value;
		}
	}

	public bool Autogenerated
	{
		get
		{
			return bool_0;
		}
		set
		{
			bool_0 = value;
		}
	}

	public long Data1
	{
		get
		{
			return long_2;
		}
		set
		{
			long_2 = value;
		}
	}

	public long Data2
	{
		get
		{
			return long_3;
		}
		set
		{
			long_3 = value;
		}
	}

	public long Data3
	{
		get
		{
			return long_4;
		}
		set
		{
			long_4 = value;
		}
	}

	public Enum113 Operation
	{
		get
		{
			return enum113_0;
		}
		set
		{
			enum113_0 = value;
		}
	}

	public Class541(string name, string formula, Dictionary<string, int> nameToIndex, List<Class541> geomGuides)
	{
		string_0 = name;
		smethod_0(formula, nameToIndex, geomGuides, out enum113_0, out var _, out long_2, out long_3, out long_4);
	}

	public Class541(string name, Enum113 operation, long data1, long data2, long data3)
	{
		string_0 = name;
		enum113_0 = operation;
		long_2 = data1;
		long_3 = data2;
		long_4 = data3;
	}

	public Class541(string name, Enum113 operation, long data1, long data2, long data3, bool autogenerated)
		: this(name, operation, data1, data2, data3)
	{
		bool_0 = autogenerated;
	}

	internal static void smethod_0(string formula, Dictionary<string, int> nameToIndex, List<Class541> geomGuides, out Enum113 operation, out int parametersCount, out long data1, out long data2, out long data3)
	{
		int i = 0;
		for (int length = formula.Length; i < length && formula[i] != ' '; i++)
		{
		}
		int num = class1151_0[formula.Substring(0, i)];
		operation = (Enum113)num;
		parametersCount = int_0[num];
		data1 = smethod_1(formula, nameToIndex, geomGuides, ref i);
		if (parametersCount > 1)
		{
			data2 = smethod_1(formula, nameToIndex, geomGuides, ref i);
			if (parametersCount > 2)
			{
				data3 = smethod_1(formula, nameToIndex, geomGuides, ref i);
			}
			else
			{
				data3 = 0L;
			}
		}
		else
		{
			data3 = 0L;
			data2 = 0L;
		}
	}

	private static long smethod_1(string formula, Dictionary<string, int> nameToIndex, List<Class541> geomGuides, ref int pos)
	{
		int length = formula.Length;
		while (pos < length && formula[pos] == ' ')
		{
			pos++;
		}
		int num = pos;
		while (pos < length && formula[pos] != ' ')
		{
			pos++;
		}
		return Class342.smethod_0(formula.Substring(num, pos - num), nameToIndex, geomGuides);
	}

	public string method_0(Class541[] geomGuides, Class341[] values, string[] modifiersOrder)
	{
		StringBuilder stringBuilder = new StringBuilder(32);
		switch (class1151_0[(int)enum113_0])
		{
		case "*/":
			stringBuilder.AppendFormat("{0}*{1}/{2}", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder), Class342.smethod_1(long_4, geomGuides, values, modifiersOrder));
			break;
		case "+-":
			stringBuilder.AppendFormat("{0}+{1}-{2}", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder), Class342.smethod_1(long_4, geomGuides, values, modifiersOrder));
			break;
		case "+/":
			stringBuilder.AppendFormat("{0}+{1}/{2}", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder), Class342.smethod_1(long_4, geomGuides, values, modifiersOrder));
			break;
		case "?:":
			stringBuilder.AppendFormat("if({0},{1},{2})", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder), Class342.smethod_1(long_4, geomGuides, values, modifiersOrder));
			break;
		case "abs":
			stringBuilder.AppendFormat("abs({0})", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder));
			break;
		case "at2":
			stringBuilder.AppendFormat("atan2({0},{1})", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder));
			break;
		case "cat2":
			stringBuilder.AppendFormat("{0}*(cos(atan({2} / {1}))", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder), Class342.smethod_1(long_4, geomGuides, values, modifiersOrder));
			break;
		case "cos":
			stringBuilder.AppendFormat("{0}*cos({1})", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder));
			break;
		case "max":
			stringBuilder.AppendFormat("max({0},{1})", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder));
			break;
		case "min":
			stringBuilder.AppendFormat("min({0},{1})", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder));
			break;
		case "mod":
			stringBuilder.AppendFormat("sqrt({0}*{0} + {1}{1} + {2}{2})", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder), Class342.smethod_1(long_4, geomGuides, values, modifiersOrder));
			break;
		case "pin":
			stringBuilder.AppendFormat("if({0},{1},{2})", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder), Class342.smethod_1(long_4, geomGuides, values, modifiersOrder));
			break;
		case "sat2":
			stringBuilder.AppendFormat("{0}*(sin(atan({2} / {1}))", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder), Class342.smethod_1(long_4, geomGuides, values, modifiersOrder));
			break;
		case "sin":
			stringBuilder.AppendFormat("{0}*sin({1})", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder));
			break;
		case "sqrt":
			stringBuilder.AppendFormat("sqrt({0})", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder));
			break;
		case "tan":
			stringBuilder.AppendFormat("{0}*tan({1})", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder), Class342.smethod_1(long_3, geomGuides, values, modifiersOrder));
			break;
		case "val":
			stringBuilder.AppendFormat("{0}", Class342.smethod_1(long_2, geomGuides, values, modifiersOrder));
			break;
		default:
			stringBuilder.Append("0");
			break;
		}
		return stringBuilder.ToString();
	}
}
