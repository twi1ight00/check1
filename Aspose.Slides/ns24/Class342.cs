using System;
using System.Collections.Generic;
using System.Xml;
using Aspose.Slides;

namespace ns24;

internal class Class342 : Class278
{
	[Flags]
	internal enum Enum164 : byte
	{
		flag_0 = 0,
		flag_1 = 1,
		flag_2 = 2,
		flag_3 = 4,
		flag_4 = 8,
		flag_5 = 0x10
	}

	public const int int_0 = 11;

	public const long long_0 = -27273042329612L;

	public const long long_1 = -27273042329600L;

	public const long long_2 = 27273042316901L;

	private const double double_0 = 2.9088820866572157E-07;

	public static readonly string[] string_0 = new string[11]
	{
		"0", "width", "height", "0", "0", "0", "0", "left", "top", "right",
		"bottom"
	};

	private ShapeType shapeType_0 = ShapeType.NotDefined;

	private Class342 class342_0;

	private Class341[] class341_0 = new Class341[0];

	private Class888[] class888_0;

	private Class886[] class886_0;

	private Class541[] class541_0;

	private Class516[] class516_0;

	private Class887[] class887_0;

	private Class887[] class887_1;

	public Class341[] Adjustments
	{
		get
		{
			return class341_0;
		}
		set
		{
			class341_0 = value;
		}
	}

	public Class888[] ConnSites
	{
		get
		{
			return class888_0;
		}
		set
		{
			class888_0 = value;
		}
	}

	public Class886[] AdjustHandles
	{
		get
		{
			return class886_0;
		}
		set
		{
			class886_0 = value;
		}
	}

	public Class541[] GeomGuides
	{
		get
		{
			return class541_0;
		}
		set
		{
			class541_0 = value;
		}
	}

	public Class516[] Paths
	{
		get
		{
			return class516_0;
		}
		set
		{
			class516_0 = value;
		}
	}

	public Class887[] RectTopLeft
	{
		get
		{
			return class887_0;
		}
		set
		{
			class887_0 = value;
		}
	}

	public Class887[] RectBottomRight
	{
		get
		{
			return class887_1;
		}
		set
		{
			class887_1 = value;
		}
	}

	public ShapeType RawPreset
	{
		get
		{
			return shapeType_0;
		}
		set
		{
			shapeType_0 = value;
		}
	}

	public Class342 Template
	{
		get
		{
			return class342_0;
		}
		set
		{
			class342_0 = value;
		}
	}

	public Class342()
	{
	}

	public Class342(Class341[] adjustments, Class541[] geomGuides, Class888[] connSites, Class886[] adjustHandles, Class516[] paths, Class887 rectTopLeft, Class887 rectBottomRight)
	{
		shapeType_0 = ShapeType.Custom;
		class341_0 = adjustments;
		class888_0 = connSites;
		class886_0 = adjustHandles;
		class541_0 = geomGuides;
		class516_0 = paths;
		if (rectTopLeft != null)
		{
			class887_0 = new Class887[1];
			class887_0[0] = rectTopLeft;
			class887_1 = new Class887[1];
			class887_1[0] = rectBottomRight;
		}
	}

	public static long smethod_0(string value, Dictionary<string, int> namesToIndex, List<Class541> geomGuides)
	{
		if (value == "")
		{
			return long.MaxValue;
		}
		int i = 0;
		int length;
		for (length = value.Length; i < length && value[i] == ' '; i++)
		{
		}
		int num = 1;
		if (value[i] == '-')
		{
			i++;
			num = -1;
			for (; i < length && value[i] == ' '; i++)
			{
			}
		}
		else if (value[i] == '+')
		{
			for (i++; i < length && value[i] == ' '; i++)
			{
			}
		}
		long num2 = 0L;
		bool flag = true;
		for (; i < length; i++)
		{
			char c = value[i];
			if (c >= '0' && c <= '9')
			{
				num2 = num2 * 10L + (c - 48);
				continue;
			}
			flag = false;
			break;
		}
		if (flag)
		{
			return num * num2;
		}
		if (!namesToIndex.TryGetValue(value, out var value2))
		{
			if (num2 == 0L)
			{
				num2 = 1L;
			}
			length--;
			long num3 = 1L;
			long num4 = 0L;
			while (i < length && value[length] >= '0' && value[length] <= '9')
			{
				num4 += (value[length--] - 48) * num3;
				num3 *= 10L;
			}
			if (num4 == 0L)
			{
				length++;
				num4 = 1L;
			}
			else if (length == i || value[length] != 'd')
			{
				throw new PptxReadException($"Invalid adjustable \"{value}\"");
			}
			string text = value.Substring(i, length - i);
			if (value == text)
			{
				throw new PptxReadException($"Invalid adjustable \"{value}\"");
			}
			geomGuides.Add(null);
			int num6 = (namesToIndex[value] = -geomGuides.Count - 11);
			value2 = num6;
			geomGuides[geomGuides.Count - 1] = new Class541(value, Enum113.const_0, smethod_0(text, namesToIndex, geomGuides), num * num2, num4, autogenerated: true);
		}
		int num7 = value2;
		if (num7 < 0)
		{
			return -27273042329600L + num7;
		}
		return 27273042316900L + num7;
	}

	public float method_0(double[] guideValues, Enum164[] guideValueFlags, long value)
	{
		Enum164 geomRef = Enum164.flag_0;
		return method_2(guideValues, guideValueFlags, value, out geomRef);
	}

	public float method_1(double[] guideValues, Enum164[] guideValueFlags, long value)
	{
		Enum164 geomRef;
		return method_2(guideValues, guideValueFlags, value, out geomRef) / 60000f;
	}

	public float method_2(double[] guideValues, Enum164[] guideValueFlags, long value, out Enum164 geomRef)
	{
		geomRef = Enum164.flag_0;
		if (value < -27273042329600L)
		{
			geomRef = guideValueFlags[-27273042329600L - value - 1L];
			return (float)guideValues[-27273042329600L - value - 1L];
		}
		if (value <= 27273042316900L)
		{
			return value;
		}
		return class341_0[value - 27273042316900L - 1L].RawValue;
	}

	public static string smethod_1(long value, Class541[] geomGuides, Class341[] values, string[] modifiersOrder)
	{
		if (value < -27273042329600L)
		{
			if (value <= -27273042329612L)
			{
				return "?" + Array.IndexOf(modifiersOrder, geomGuides[-27273042329612L - value].Name);
			}
			return string_0[-27273042329601L - value];
		}
		if (value <= 27273042316900L)
		{
			return XmlConvert.ToString(value);
		}
		if (value == long.MaxValue)
		{
			return "";
		}
		return "$" + values[value - 27273042316900L - 1L].Name;
	}

	public static long smethod_2(List<Class541> geomGuides, Enum113 operation, long param1, long param2, long param3)
	{
		if (param1 >= -27273042329600L && param1 <= 27273042316900L && param2 >= -27273042329600L && param2 <= 27273042316900L && param3 >= -27273042329600L && param3 <= 27273042316900L)
		{
			double num = param1;
			double num2 = param2;
			double num3 = param3;
			double num4 = 0.0;
			switch (operation)
			{
			case Enum113.const_0:
				num4 = num * num2 / num3;
				break;
			case Enum113.const_1:
				num4 = num + num2 - num3;
				break;
			case Enum113.const_2:
				num4 = (num + num2) / num3;
				break;
			case Enum113.const_3:
				if (param1 <= 0L)
				{
					return param3;
				}
				return param2;
			case Enum113.const_4:
				return Math.Abs(param1);
			case Enum113.const_5:
				num4 = Math.Atan2(num2, num) / 2.9088820866572157E-07;
				break;
			case Enum113.const_6:
				num4 = num * Math.Cos(Math.Atan2(num3, num2));
				break;
			case Enum113.const_7:
				num4 = num * Math.Cos(num2 * 2.9088820866572157E-07);
				break;
			case Enum113.const_8:
				return Math.Max(param1, param2);
			case Enum113.const_9:
				return Math.Min(param1, param2);
			case Enum113.const_10:
				num4 = Math.Sqrt(num * num + num2 * num2 + num3 * num3);
				break;
			case Enum113.const_11:
				num4 = ((num > num2) ? num : ((num2 > num3) ? num3 : num2));
				break;
			case Enum113.const_12:
				num4 = num * Math.Sin(Math.Atan2(num3, num2));
				break;
			case Enum113.const_13:
				num4 = num * Math.Sin(num2 * 2.9088820866572157E-07);
				break;
			case Enum113.const_14:
				num4 = Math.Sqrt(num);
				break;
			case Enum113.const_15:
				num4 = num * Math.Tan(num2 * 2.9088820866572157E-07);
				break;
			case Enum113.const_16:
				num4 = num;
				break;
			}
			if (num4 != 0.0)
			{
				double num5 = Math.Round(num4);
				if (Math.Abs((num5 - num4) / (num5 + num4)) < 0.01)
				{
					return (long)num5;
				}
			}
			return 0L;
		}
		if (operation != Enum113.const_1 && operation != 0)
		{
			if (operation == Enum113.const_2 && param3 == 1L)
			{
				if (param1 == 0L)
				{
					return param2;
				}
				if (param2 == 0L)
				{
					return param1;
				}
			}
			else if (operation == Enum113.const_3 && param1 >= -27273042329600L && param1 <= 27273042316900L)
			{
				if (param1 <= 0L)
				{
					return param3;
				}
				return param2;
			}
		}
		else
		{
			if (param1 == param3)
			{
				return param2;
			}
			if (param2 == param3)
			{
				return param1;
			}
			if (operation == Enum113.const_0 && (param1 == 0L || param2 == 0L))
			{
				return 0L;
			}
		}
		int num6 = 0;
		while (true)
		{
			if (num6 < geomGuides.Count)
			{
				Class541 @class = geomGuides[num6];
				if (@class != null && @class.Operation == operation && @class.Data1 == param1 && @class.Data2 == param2 && @class.Data3 == param3)
				{
					break;
				}
				num6++;
				continue;
			}
			geomGuides.Add(new Class541("GT" + geomGuides.Count, operation, param1, param2, param3));
			return smethod_3(geomGuides.Count - 1);
		}
		return smethod_3(num6);
	}

	private static long smethod_3(int index)
	{
		return -27273042329600L - index - 11L - 1L;
	}
}
